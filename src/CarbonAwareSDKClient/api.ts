/* tslint:disable */
/* eslint-disable */
/**
 * CarbonAware.WebApi
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CarbonIntensityBatchDTO
 */
export interface CarbonIntensityBatchDTO {
    /**
     * the location name where workflow is run
     * @type {string}
     * @memberof CarbonIntensityBatchDTO
     */
    'location': string;
    /**
     * the time at which the workflow we are measuring carbon intensity for started
     * @type {string}
     * @memberof CarbonIntensityBatchDTO
     */
    'startTime': string;
    /**
     * the time at which the workflow we are measuring carbon intensity for ended
     * @type {string}
     * @memberof CarbonIntensityBatchDTO
     */
    'endTime': string;
}
/**
 * 
 * @export
 * @interface CarbonIntensityDTO
 */
export interface CarbonIntensityDTO {
    /**
     * the location name where workflow is run
     * @type {string}
     * @memberof CarbonIntensityDTO
     */
    'location': string;
    /**
     * the time at which the workflow we are measuring carbon intensity for started
     * @type {string}
     * @memberof CarbonIntensityDTO
     */
    'startTime': string;
    /**
     * the time at which the workflow we are measuring carbon intensity for ended
     * @type {string}
     * @memberof CarbonIntensityDTO
     */
    'endTime': string;
    /**
     * Value of the marginal carbon intensity in grams per kilowatt-hour.
     * @type {number}
     * @memberof CarbonIntensityDTO
     */
    'carbonIntensity'?: number;
}
/**
 * 
 * @export
 * @interface EmissionsData
 */
export interface EmissionsData {
    /**
     * 
     * @type {string}
     * @memberof EmissionsData
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmissionsData
     */
    'time'?: string;
    /**
     * 
     * @type {number}
     * @memberof EmissionsData
     */
    'rating'?: number;
    /**
     * 
     * @type {TimeSpan}
     * @memberof EmissionsData
     */
    'duration'?: TimeSpan;
}
/**
 * 
 * @export
 * @interface EmissionsDataDTO
 */
export interface EmissionsDataDTO {
    /**
     * 
     * @type {string}
     * @memberof EmissionsDataDTO
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmissionsDataDTO
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof EmissionsDataDTO
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmissionsDataDTO
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface EmissionsForecastBatchDTO
 */
export interface EmissionsForecastBatchDTO {
    /**
     * For historical forecast requests, this value is the timestamp used to access the most  recently generated forecast as of that time.
     * @type {string}
     * @memberof EmissionsForecastBatchDTO
     */
    'requestedAt': string;
    /**
     * Start time boundary of forecasted data points. Ignores forecast data points before this time.  Defaults to the earliest time in the forecast data.
     * @type {string}
     * @memberof EmissionsForecastBatchDTO
     */
    'dataStartAt'?: string;
    /**
     * End time boundary of forecasted data points. Ignores forecast data points after this time.  Defaults to the latest time in the forecast data.
     * @type {string}
     * @memberof EmissionsForecastBatchDTO
     */
    'dataEndAt'?: string;
    /**
     * The estimated duration (in minutes) of the workload.  Defaults to the duration of a single forecast data point.
     * @type {number}
     * @memberof EmissionsForecastBatchDTO
     */
    'windowSize'?: number;
    /**
     * The location of the forecast
     * @type {string}
     * @memberof EmissionsForecastBatchDTO
     */
    'location': string;
}
/**
 * 
 * @export
 * @interface EmissionsForecastDTO
 */
export interface EmissionsForecastDTO {
    /**
     * For current requests, this value is the timestamp the request for forecast data was made.  For historical forecast requests, this value is the timestamp used to access the most   recently generated forecast as of that time.
     * @type {string}
     * @memberof EmissionsForecastDTO
     */
    'requestedAt': string;
    /**
     * The location of the forecast
     * @type {string}
     * @memberof EmissionsForecastDTO
     */
    'location': string;
    /**
     * Start time boundary of forecasted data points. Ignores forecast data points before this time.  Defaults to the earliest time in the forecast data.
     * @type {string}
     * @memberof EmissionsForecastDTO
     */
    'dataStartAt'?: string;
    /**
     * End time boundary of forecasted data points. Ignores forecast data points after this time.  Defaults to the latest time in the forecast data.
     * @type {string}
     * @memberof EmissionsForecastDTO
     */
    'dataEndAt'?: string;
    /**
     * The estimated duration (in minutes) of the workload.  Defaults to the duration of a single forecast data point.
     * @type {number}
     * @memberof EmissionsForecastDTO
     */
    'windowSize'?: number;
    /**
     * Timestamp when the forecast was generated.
     * @type {string}
     * @memberof EmissionsForecastDTO
     */
    'generatedAt'?: string;
    /**
     * 
     * @type {EmissionsDataDTO}
     * @memberof EmissionsForecastDTO
     */
    'optimalDataPoint'?: EmissionsDataDTO;
    /**
     * The forecasted data points transformed and filtered to reflect the specified time and window parameters.  Points are ordered chronologically; Empty array if all data points were filtered out.  E.G. dataStartAt and dataEndAt times outside the forecast period; windowSize greater than total duration of forecast data;
     * @type {Array<EmissionsDataDTO>}
     * @memberof EmissionsForecastDTO
     */
    'forecastData'?: Array<EmissionsDataDTO> | null;
}
/**
 * 
 * @export
 * @interface TimeSpan
 */
export interface TimeSpan {
    /**
     * 
     * @type {number}
     * @memberof TimeSpan
     */
    'ticks'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSpan
     */
    'days'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSpan
     */
    'hours'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSpan
     */
    'milliseconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSpan
     */
    'minutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSpan
     */
    'seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSpan
     */
    'totalDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSpan
     */
    'totalHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSpan
     */
    'totalMilliseconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSpan
     */
    'totalMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSpan
     */
    'totalSeconds'?: number;
}
/**
 * 
 * @export
 * @interface ValidationProblemDetails
 */
export interface ValidationProblemDetails {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ValidationProblemDetails
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ValidationProblemDetails
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ValidationProblemDetails
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ValidationProblemDetails
     */
    'detail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ValidationProblemDetails
     */
    'instance'?: string | null;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ValidationProblemDetails
     */
    'errors'?: { [key: string]: Array<string>; } | null;
}

/**
 * CarbonAwareApi - axios parameter creator
 * @export
 */
export const CarbonAwareApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint takes a batch of requests for historical forecast data, fetches them, and calculates the optimal   marginal carbon intensity windows for each using the same parameters available to the \'/emissions/forecasts/current\'  endpoint.                This endpoint is useful for back-testing what one might have done in the past, if they had access to the   current forecast at the time.
         * @summary Given an array of historical forecasts, retrieves the data that contains  forecasts metadata, the optimal forecast and a range of forecasts filtered by the attributes [start...end] if provided.
         * @param {Array<EmissionsForecastBatchDTO>} [emissionsForecastBatchDTO] Array of requested forecasts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchForecastDataAsync: async (emissionsForecastBatchDTO?: Array<EmissionsForecastBatchDTO>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/emissions/forecasts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emissionsForecastBatchDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is useful for reporting the measured carbon intensity for a specific time period in a specific location.
         * @summary Retrieves the measured carbon intensity data between the time boundaries and calculates the average carbon intensity during that period.
         * @param {string} location The location name of the region that we are measuring carbon usage in.
         * @param {string} startTime The time at which the workload and corresponding carbon usage begins.
         * @param {string} endTime The time at which the workload and corresponding carbon usage ends.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAverageCarbonIntensity: async (location: string, startTime: string, endTime: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('getAverageCarbonIntensity', 'location', location)
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getAverageCarbonIntensity', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getAverageCarbonIntensity', 'endTime', endTime)
            const localVarPath = `/emissions/average-carbon-intensity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The application only supports batching across a single location with different time boundaries. If multiple locations are provided, an error is returned.  For each item in the request array, the application returns a corresponding object containing the location, time boundaries, and average marginal carbon intensity.
         * @summary Given an array of request objects, each with their own location and time boundaries, calculate the average carbon intensity for that location and time period   and return an array of carbon intensity objects.
         * @param {Array<CarbonIntensityBatchDTO>} [carbonIntensityBatchDTO] Array of inputs where each contains a \&quot;location\&quot;, \&quot;startDate\&quot;, and \&quot;endDate\&quot; for which to calculate average marginal carbon intensity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAverageCarbonIntensityBatch: async (carbonIntensityBatchDTO?: Array<CarbonIntensityBatchDTO>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/emissions/average-carbon-intensity/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(carbonIntensityBatchDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Calculate the best emission data by location for a specified time period.
         * @param {Array<string>} location String array of named locations.
         * @param {string} [time] [Optional] Start time for the data query.
         * @param {string} [toTime] [Optional] End time for the data query.
         * @param {number} [durationMinutes] [Optional] Duration for the data query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBestEmissionsDataForLocationsByTime: async (location: Array<string>, time?: string, toTime?: string, durationMinutes?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('getBestEmissionsDataForLocationsByTime', 'location', location)
            const localVarPath = `/emissions/bylocations/best`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = (time as any instanceof Date) ?
                    (time as any).toISOString() :
                    time;
            }

            if (toTime !== undefined) {
                localVarQueryParameter['toTime'] = (toTime as any instanceof Date) ?
                    (toTime as any).toISOString() :
                    toTime;
            }

            if (durationMinutes !== undefined) {
                localVarQueryParameter['durationMinutes'] = durationMinutes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint fetches only the most recently generated forecast for all provided locations.  It uses the \"dataStartAt\" and   \"dataEndAt\" parameters to scope the forecasted data points (if available for those times). If no start or end time   boundaries are provided, the entire forecast dataset is used. The scoped data points are used to calculate average marginal   carbon intensities of the specified \"windowSize\" and the optimal marginal carbon intensity window is identified.                The forecast data represents what the data source predicts future marginal carbon intesity values to be,   not actual measured emissions data (as future values cannot be known).                This endpoint is useful for determining if there is a more carbon-optimal time to use electicity predicted in the future.
         * @summary Retrieves the most recent forecasted data and calculates the optimal marginal carbon intensity window.
         * @param {Array<string>} location String array of named locations.
         * @param {string} [dataStartAt] Start time boundary of forecasted data points. Ignores current forecast data points before this time.  Defaults to the earliest time in the forecast data.
         * @param {string} [dataEndAt] End time boundary of forecasted data points. Ignores current forecast data points after this time.  Defaults to the latest time in the forecast data.
         * @param {number} [windowSize] The estimated duration (in minutes) of the workload.  Defaults to the duration of a single forecast data point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentForecastData: async (location: Array<string>, dataStartAt?: string, dataEndAt?: string, windowSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('getCurrentForecastData', 'location', location)
            const localVarPath = `/emissions/forecasts/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (dataStartAt !== undefined) {
                localVarQueryParameter['dataStartAt'] = (dataStartAt as any instanceof Date) ?
                    (dataStartAt as any).toISOString() :
                    dataStartAt;
            }

            if (dataEndAt !== undefined) {
                localVarQueryParameter['dataEndAt'] = (dataEndAt as any instanceof Date) ?
                    (dataEndAt as any).toISOString() :
                    dataEndAt;
            }

            if (windowSize !== undefined) {
                localVarQueryParameter['windowSize'] = windowSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Calculate the best emission data by location for a specified time period.
         * @param {string} location String named location.
         * @param {string} [time] [Optional] Start time for the data query.
         * @param {string} [toTime] [Optional] End time for the data query.
         * @param {number} [durationMinutes] [Optional] Duration for the data query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmissionsDataForLocationByTime: async (location: string, time?: string, toTime?: string, durationMinutes?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('getEmissionsDataForLocationByTime', 'location', location)
            const localVarPath = `/emissions/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = (time as any instanceof Date) ?
                    (time as any).toISOString() :
                    time;
            }

            if (toTime !== undefined) {
                localVarQueryParameter['toTime'] = (toTime as any instanceof Date) ?
                    (toTime as any).toISOString() :
                    toTime;
            }

            if (durationMinutes !== undefined) {
                localVarQueryParameter['durationMinutes'] = durationMinutes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Calculate the observed emission data by list of locations for a specified time period.
         * @param {Array<string>} location String array of named locations.
         * @param {string} [time] [Optional] Start time for the data query.
         * @param {string} [toTime] [Optional] End time for the data query.
         * @param {number} [durationMinutes] [Optional] Duration for the data query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmissionsDataForLocationsByTime: async (location: Array<string>, time?: string, toTime?: string, durationMinutes?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('getEmissionsDataForLocationsByTime', 'location', location)
            const localVarPath = `/emissions/bylocations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = (time as any instanceof Date) ?
                    (time as any).toISOString() :
                    time;
            }

            if (toTime !== undefined) {
                localVarQueryParameter['toTime'] = (toTime as any instanceof Date) ?
                    (toTime as any).toISOString() :
                    toTime;
            }

            if (durationMinutes !== undefined) {
                localVarQueryParameter['durationMinutes'] = durationMinutes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarbonAwareApi - functional programming interface
 * @export
 */
export const CarbonAwareApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CarbonAwareApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint takes a batch of requests for historical forecast data, fetches them, and calculates the optimal   marginal carbon intensity windows for each using the same parameters available to the \'/emissions/forecasts/current\'  endpoint.                This endpoint is useful for back-testing what one might have done in the past, if they had access to the   current forecast at the time.
         * @summary Given an array of historical forecasts, retrieves the data that contains  forecasts metadata, the optimal forecast and a range of forecasts filtered by the attributes [start...end] if provided.
         * @param {Array<EmissionsForecastBatchDTO>} [emissionsForecastBatchDTO] Array of requested forecasts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchForecastDataAsync(emissionsForecastBatchDTO?: Array<EmissionsForecastBatchDTO>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmissionsForecastDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchForecastDataAsync(emissionsForecastBatchDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is useful for reporting the measured carbon intensity for a specific time period in a specific location.
         * @summary Retrieves the measured carbon intensity data between the time boundaries and calculates the average carbon intensity during that period.
         * @param {string} location The location name of the region that we are measuring carbon usage in.
         * @param {string} startTime The time at which the workload and corresponding carbon usage begins.
         * @param {string} endTime The time at which the workload and corresponding carbon usage ends.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAverageCarbonIntensity(location: string, startTime: string, endTime: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarbonIntensityDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAverageCarbonIntensity(location, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The application only supports batching across a single location with different time boundaries. If multiple locations are provided, an error is returned.  For each item in the request array, the application returns a corresponding object containing the location, time boundaries, and average marginal carbon intensity.
         * @summary Given an array of request objects, each with their own location and time boundaries, calculate the average carbon intensity for that location and time period   and return an array of carbon intensity objects.
         * @param {Array<CarbonIntensityBatchDTO>} [carbonIntensityBatchDTO] Array of inputs where each contains a \&quot;location\&quot;, \&quot;startDate\&quot;, and \&quot;endDate\&quot; for which to calculate average marginal carbon intensity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAverageCarbonIntensityBatch(carbonIntensityBatchDTO?: Array<CarbonIntensityBatchDTO>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CarbonIntensityDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAverageCarbonIntensityBatch(carbonIntensityBatchDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Calculate the best emission data by location for a specified time period.
         * @param {Array<string>} location String array of named locations.
         * @param {string} [time] [Optional] Start time for the data query.
         * @param {string} [toTime] [Optional] End time for the data query.
         * @param {number} [durationMinutes] [Optional] Duration for the data query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBestEmissionsDataForLocationsByTime(location: Array<string>, time?: string, toTime?: string, durationMinutes?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmissionsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBestEmissionsDataForLocationsByTime(location, time, toTime, durationMinutes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint fetches only the most recently generated forecast for all provided locations.  It uses the \"dataStartAt\" and   \"dataEndAt\" parameters to scope the forecasted data points (if available for those times). If no start or end time   boundaries are provided, the entire forecast dataset is used. The scoped data points are used to calculate average marginal   carbon intensities of the specified \"windowSize\" and the optimal marginal carbon intensity window is identified.                The forecast data represents what the data source predicts future marginal carbon intesity values to be,   not actual measured emissions data (as future values cannot be known).                This endpoint is useful for determining if there is a more carbon-optimal time to use electicity predicted in the future.
         * @summary Retrieves the most recent forecasted data and calculates the optimal marginal carbon intensity window.
         * @param {Array<string>} location String array of named locations.
         * @param {string} [dataStartAt] Start time boundary of forecasted data points. Ignores current forecast data points before this time.  Defaults to the earliest time in the forecast data.
         * @param {string} [dataEndAt] End time boundary of forecasted data points. Ignores current forecast data points after this time.  Defaults to the latest time in the forecast data.
         * @param {number} [windowSize] The estimated duration (in minutes) of the workload.  Defaults to the duration of a single forecast data point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentForecastData(location: Array<string>, dataStartAt?: string, dataEndAt?: string, windowSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmissionsForecastDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentForecastData(location, dataStartAt, dataEndAt, windowSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Calculate the best emission data by location for a specified time period.
         * @param {string} location String named location.
         * @param {string} [time] [Optional] Start time for the data query.
         * @param {string} [toTime] [Optional] End time for the data query.
         * @param {number} [durationMinutes] [Optional] Duration for the data query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmissionsDataForLocationByTime(location: string, time?: string, toTime?: string, durationMinutes?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmissionsData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmissionsDataForLocationByTime(location, time, toTime, durationMinutes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Calculate the observed emission data by list of locations for a specified time period.
         * @param {Array<string>} location String array of named locations.
         * @param {string} [time] [Optional] Start time for the data query.
         * @param {string} [toTime] [Optional] End time for the data query.
         * @param {number} [durationMinutes] [Optional] Duration for the data query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmissionsDataForLocationsByTime(location: Array<string>, time?: string, toTime?: string, durationMinutes?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmissionsData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmissionsDataForLocationsByTime(location, time, toTime, durationMinutes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CarbonAwareApi - factory interface
 * @export
 */
export const CarbonAwareApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarbonAwareApiFp(configuration)
    return {
        /**
         * This endpoint takes a batch of requests for historical forecast data, fetches them, and calculates the optimal   marginal carbon intensity windows for each using the same parameters available to the \'/emissions/forecasts/current\'  endpoint.                This endpoint is useful for back-testing what one might have done in the past, if they had access to the   current forecast at the time.
         * @summary Given an array of historical forecasts, retrieves the data that contains  forecasts metadata, the optimal forecast and a range of forecasts filtered by the attributes [start...end] if provided.
         * @param {Array<EmissionsForecastBatchDTO>} [emissionsForecastBatchDTO] Array of requested forecasts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchForecastDataAsync(emissionsForecastBatchDTO?: Array<EmissionsForecastBatchDTO>, options?: any): AxiosPromise<Array<EmissionsForecastDTO>> {
            return localVarFp.batchForecastDataAsync(emissionsForecastBatchDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is useful for reporting the measured carbon intensity for a specific time period in a specific location.
         * @summary Retrieves the measured carbon intensity data between the time boundaries and calculates the average carbon intensity during that period.
         * @param {string} location The location name of the region that we are measuring carbon usage in.
         * @param {string} startTime The time at which the workload and corresponding carbon usage begins.
         * @param {string} endTime The time at which the workload and corresponding carbon usage ends.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAverageCarbonIntensity(location: string, startTime: string, endTime: string, options?: any): AxiosPromise<CarbonIntensityDTO> {
            return localVarFp.getAverageCarbonIntensity(location, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The application only supports batching across a single location with different time boundaries. If multiple locations are provided, an error is returned.  For each item in the request array, the application returns a corresponding object containing the location, time boundaries, and average marginal carbon intensity.
         * @summary Given an array of request objects, each with their own location and time boundaries, calculate the average carbon intensity for that location and time period   and return an array of carbon intensity objects.
         * @param {Array<CarbonIntensityBatchDTO>} [carbonIntensityBatchDTO] Array of inputs where each contains a \&quot;location\&quot;, \&quot;startDate\&quot;, and \&quot;endDate\&quot; for which to calculate average marginal carbon intensity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAverageCarbonIntensityBatch(carbonIntensityBatchDTO?: Array<CarbonIntensityBatchDTO>, options?: any): AxiosPromise<Array<CarbonIntensityDTO>> {
            return localVarFp.getAverageCarbonIntensityBatch(carbonIntensityBatchDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Calculate the best emission data by location for a specified time period.
         * @param {Array<string>} location String array of named locations.
         * @param {string} [time] [Optional] Start time for the data query.
         * @param {string} [toTime] [Optional] End time for the data query.
         * @param {number} [durationMinutes] [Optional] Duration for the data query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBestEmissionsDataForLocationsByTime(location: Array<string>, time?: string, toTime?: string, durationMinutes?: number, options?: any): AxiosPromise<EmissionsData> {
            return localVarFp.getBestEmissionsDataForLocationsByTime(location, time, toTime, durationMinutes, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint fetches only the most recently generated forecast for all provided locations.  It uses the \"dataStartAt\" and   \"dataEndAt\" parameters to scope the forecasted data points (if available for those times). If no start or end time   boundaries are provided, the entire forecast dataset is used. The scoped data points are used to calculate average marginal   carbon intensities of the specified \"windowSize\" and the optimal marginal carbon intensity window is identified.                The forecast data represents what the data source predicts future marginal carbon intesity values to be,   not actual measured emissions data (as future values cannot be known).                This endpoint is useful for determining if there is a more carbon-optimal time to use electicity predicted in the future.
         * @summary Retrieves the most recent forecasted data and calculates the optimal marginal carbon intensity window.
         * @param {Array<string>} location String array of named locations.
         * @param {string} [dataStartAt] Start time boundary of forecasted data points. Ignores current forecast data points before this time.  Defaults to the earliest time in the forecast data.
         * @param {string} [dataEndAt] End time boundary of forecasted data points. Ignores current forecast data points after this time.  Defaults to the latest time in the forecast data.
         * @param {number} [windowSize] The estimated duration (in minutes) of the workload.  Defaults to the duration of a single forecast data point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentForecastData(location: Array<string>, dataStartAt?: string, dataEndAt?: string, windowSize?: number, options?: any): AxiosPromise<Array<EmissionsForecastDTO>> {
            return localVarFp.getCurrentForecastData(location, dataStartAt, dataEndAt, windowSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Calculate the best emission data by location for a specified time period.
         * @param {string} location String named location.
         * @param {string} [time] [Optional] Start time for the data query.
         * @param {string} [toTime] [Optional] End time for the data query.
         * @param {number} [durationMinutes] [Optional] Duration for the data query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmissionsDataForLocationByTime(location: string, time?: string, toTime?: string, durationMinutes?: number, options?: any): AxiosPromise<Array<EmissionsData>> {
            return localVarFp.getEmissionsDataForLocationByTime(location, time, toTime, durationMinutes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Calculate the observed emission data by list of locations for a specified time period.
         * @param {Array<string>} location String array of named locations.
         * @param {string} [time] [Optional] Start time for the data query.
         * @param {string} [toTime] [Optional] End time for the data query.
         * @param {number} [durationMinutes] [Optional] Duration for the data query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmissionsDataForLocationsByTime(location: Array<string>, time?: string, toTime?: string, durationMinutes?: number, options?: any): AxiosPromise<Array<EmissionsData>> {
            return localVarFp.getEmissionsDataForLocationsByTime(location, time, toTime, durationMinutes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CarbonAwareApi - object-oriented interface
 * @export
 * @class CarbonAwareApi
 * @extends {BaseAPI}
 */
export class CarbonAwareApi extends BaseAPI {
    /**
     * This endpoint takes a batch of requests for historical forecast data, fetches them, and calculates the optimal   marginal carbon intensity windows for each using the same parameters available to the \'/emissions/forecasts/current\'  endpoint.                This endpoint is useful for back-testing what one might have done in the past, if they had access to the   current forecast at the time.
     * @summary Given an array of historical forecasts, retrieves the data that contains  forecasts metadata, the optimal forecast and a range of forecasts filtered by the attributes [start...end] if provided.
     * @param {Array<EmissionsForecastBatchDTO>} [emissionsForecastBatchDTO] Array of requested forecasts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarbonAwareApi
     */
    public batchForecastDataAsync(emissionsForecastBatchDTO?: Array<EmissionsForecastBatchDTO>, options?: AxiosRequestConfig) {
        return CarbonAwareApiFp(this.configuration).batchForecastDataAsync(emissionsForecastBatchDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is useful for reporting the measured carbon intensity for a specific time period in a specific location.
     * @summary Retrieves the measured carbon intensity data between the time boundaries and calculates the average carbon intensity during that period.
     * @param {string} location The location name of the region that we are measuring carbon usage in.
     * @param {string} startTime The time at which the workload and corresponding carbon usage begins.
     * @param {string} endTime The time at which the workload and corresponding carbon usage ends.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarbonAwareApi
     */
    public getAverageCarbonIntensity(location: string, startTime: string, endTime: string, options?: AxiosRequestConfig) {
        return CarbonAwareApiFp(this.configuration).getAverageCarbonIntensity(location, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The application only supports batching across a single location with different time boundaries. If multiple locations are provided, an error is returned.  For each item in the request array, the application returns a corresponding object containing the location, time boundaries, and average marginal carbon intensity.
     * @summary Given an array of request objects, each with their own location and time boundaries, calculate the average carbon intensity for that location and time period   and return an array of carbon intensity objects.
     * @param {Array<CarbonIntensityBatchDTO>} [carbonIntensityBatchDTO] Array of inputs where each contains a \&quot;location\&quot;, \&quot;startDate\&quot;, and \&quot;endDate\&quot; for which to calculate average marginal carbon intensity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarbonAwareApi
     */
    public getAverageCarbonIntensityBatch(carbonIntensityBatchDTO?: Array<CarbonIntensityBatchDTO>, options?: AxiosRequestConfig) {
        return CarbonAwareApiFp(this.configuration).getAverageCarbonIntensityBatch(carbonIntensityBatchDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Calculate the best emission data by location for a specified time period.
     * @param {Array<string>} location String array of named locations.
     * @param {string} [time] [Optional] Start time for the data query.
     * @param {string} [toTime] [Optional] End time for the data query.
     * @param {number} [durationMinutes] [Optional] Duration for the data query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarbonAwareApi
     */
    public getBestEmissionsDataForLocationsByTime(location: Array<string>, time?: string, toTime?: string, durationMinutes?: number, options?: AxiosRequestConfig) {
        return CarbonAwareApiFp(this.configuration).getBestEmissionsDataForLocationsByTime(location, time, toTime, durationMinutes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint fetches only the most recently generated forecast for all provided locations.  It uses the \"dataStartAt\" and   \"dataEndAt\" parameters to scope the forecasted data points (if available for those times). If no start or end time   boundaries are provided, the entire forecast dataset is used. The scoped data points are used to calculate average marginal   carbon intensities of the specified \"windowSize\" and the optimal marginal carbon intensity window is identified.                The forecast data represents what the data source predicts future marginal carbon intesity values to be,   not actual measured emissions data (as future values cannot be known).                This endpoint is useful for determining if there is a more carbon-optimal time to use electicity predicted in the future.
     * @summary Retrieves the most recent forecasted data and calculates the optimal marginal carbon intensity window.
     * @param {Array<string>} location String array of named locations.
     * @param {string} [dataStartAt] Start time boundary of forecasted data points. Ignores current forecast data points before this time.  Defaults to the earliest time in the forecast data.
     * @param {string} [dataEndAt] End time boundary of forecasted data points. Ignores current forecast data points after this time.  Defaults to the latest time in the forecast data.
     * @param {number} [windowSize] The estimated duration (in minutes) of the workload.  Defaults to the duration of a single forecast data point.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarbonAwareApi
     */
    public getCurrentForecastData(location: Array<string>, dataStartAt?: string, dataEndAt?: string, windowSize?: number, options?: AxiosRequestConfig) {
        return CarbonAwareApiFp(this.configuration).getCurrentForecastData(location, dataStartAt, dataEndAt, windowSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Calculate the best emission data by location for a specified time period.
     * @param {string} location String named location.
     * @param {string} [time] [Optional] Start time for the data query.
     * @param {string} [toTime] [Optional] End time for the data query.
     * @param {number} [durationMinutes] [Optional] Duration for the data query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarbonAwareApi
     */
    public getEmissionsDataForLocationByTime(location: string, time?: string, toTime?: string, durationMinutes?: number, options?: AxiosRequestConfig) {
        return CarbonAwareApiFp(this.configuration).getEmissionsDataForLocationByTime(location, time, toTime, durationMinutes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Calculate the observed emission data by list of locations for a specified time period.
     * @param {Array<string>} location String array of named locations.
     * @param {string} [time] [Optional] Start time for the data query.
     * @param {string} [toTime] [Optional] End time for the data query.
     * @param {number} [durationMinutes] [Optional] Duration for the data query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarbonAwareApi
     */
    public getEmissionsDataForLocationsByTime(location: Array<string>, time?: string, toTime?: string, durationMinutes?: number, options?: AxiosRequestConfig) {
        return CarbonAwareApiFp(this.configuration).getEmissionsDataForLocationsByTime(location, time, toTime, durationMinutes, options).then((request) => request(this.axios, this.basePath));
    }
}


